# 템플릿(template)

## 템플릿 함수 (function template)

다음과 같이 정수 두 수와 실수 두 수를 더하는 add 함수를 고려하자. C++의 함수 오버로딩 기능을 활용하여 다음과 같이 함수를 정의할 수 있다. 

``` C++
int add(int& x, int& y) { return x+y; }
```

```C++
double add(double& x, double& y) {return x+y; }
```

두 함수를 살펴보면 입력 파러미터의 자료형만 다를 뿐 알고리즘은 같다. 이 외에 입력 파러미터의 자료혐이 다르면 다른 함수를 정의하여야 한다. 
이와 같이 다른 자료형에 대해서 함수를 정의하면 전체 프로그램의 길이가 늘어나고 작업 도중 실수의 가능성이 존재하고 함수의 알고리즘이 변경되면 오버로딩된 모든 함수의
코드도 수정해 주어야 한다. 
이러한 단점을 해결하기 위해 처라하는 데이터의 자료형이 달라도 알고리즘이 같은 경우 자료형을 일반화 시키고 자료형에 대해 알고리즘을 일반화할 수 있다. C++ 언어에서는 
여러 자료형에 대해 함수나 클래스를 일반화하는 것이 가능하다. 얖에서 살펴보았던 add함수를 일반화한 함수를 정의하기 위해서 C++에서는 template 이라는 키워드가 사용된다.
template은 특정 형태를 가지는 틀의 의미로 C++에서 프로그래머가 원하는 자료형을 명시하면 자료형에 맞는 알고리즘 코드를 만들어 내는 틀이라 생각하면 된다. 
이처럼 템플릿을 사용하여 프로그래밍을 하는 것을 일반화 프로그래밍(Generic Programming)이라고 한다. 

템플릿을 만들기 위해서 template 선언이 필요하다. template 선언은 다음과 같다. 
```C++
templae <typename T>
```
T라는 자로형(타입)에 대한 템플릿을 선언한다는 의미이며 여러 자료형을 가지는 템플릿의 선언은 다음과 같이 하면 된다.
```C++
template <typename T1, typename T2,..>
```
T, T1, T2 등은 실제 프로그램 시 실제 자료형으로 대체된다. 즉 사용자가 해당 템플릿을 사용하려면 T 자료형이 선언된 위치에 값 또는 변수를 대입하여 템플릿을 호출하면
컴파일 시 대입된 자료형을 기반으로 자료형을 추론하고 해당 자료형에 맞는 함수 또는 클래스를 구현한다. 

앞의 add함수를 자료형 T에 대한 템플릿 함수로 졍의 예는 다음과 같다.
```C++
template <typename T>
T add(T& x, T& y) { return x + y; }

## 템플릿 클래스(Template Class)



