# C++14 표준의 주요 내용 

## 반환 자료형 추론 (auto): 
함수의 반환 자료형을 자동으로 추론할 수 있다. 다음 코드 들은 ``auto`` 자료형의 사용 예이다.
C++14에서 ``auto`` 반환 자료형을 사용하면 컴파일러가 자료형을 추론한다. 
람다(Lambda)를 사용하면, ``auto``를 사용하여 반환 유형을 추론할 수 있어 추론된 참조(decudec reference) 또는 
rvalue 참조(rvalue reference)의 반환이 가능해진다. 

```c++
#include <iostream>
using namespace std;

auto add(int a, double b) {    // double 로 추론
    return a + b;
}

int main(int argc, char const *argv[])
{
    cout << "add 결과: " << add(20, 30.56) << endl;
    return 0;
}
```
프로그램의 수행 결과는 다음과 같다.
```bash
add 결과: 50.56
```

```c++
#include <iostream>
using namespace std;

template <typename T>
auto& f(T& t) {
    return t;
}

auto g = [](auto& x) -> auto& { return f(x); };  // input: 참조 변수, output: 참조 값

int main(int argc, char const *argv[])
{
    int y = 100;
    auto& z = g(y);  // z: reference, g(): reference 참조를 반환
    z = 200;
    cout << y << endl; 
    return 0;
}
```
앞의 프로그램 코드에서 람다 g()는 참조 값을 반환하고 있어 참조 변수 z는 일반 변수 y의 별명의 기능을 한다. 
그 결과로 화면에 출력하는 값은 ``100``이 아니라 ``200``이다.

## 람다 표현식(Generic Lambdas)
람다 표현식에서 매개변수의 자료형을 명시하지 않고 사용할 수 있다. 다음 코드는 람다 표현식의 예이다.

(1)
```c++
#include <iostream>
using namespace std;

auto multiply = [](auto a, int b) {
    return a * b;
};

int main(int argc, char const *argv[])
{
    cout << "multiply 결과: " <<  multiply(3, 4) << endl;
    return 0;
}
```

프로그램 수행 결과는 다음과 같다.
```bash
multiply 결과: 12
```
(2) 
```c++
#include <iostream>
using namespace std;

auto identity = [](auto x) { return x;};  // identity Lambda
int main(int argc, char const *argv[])
{
    int three = identity(20);
    string str = identity("Hello World!");

    cout << "three: " << three << endl;
    cout << "string: " << str << endl;

    return 0;
}

앞의 코드의 수행 결과는 다음과 같다.
```bash
three: 20
string: Hello World!
```

## 변수 템플릿(Variable Templates)
변수 템플릿을 사용하여 템플릿을 통해 변수를 선언할 수 있다. 다음 코드는 변수 템플릿의 예이다.
```c++
#include <iostream>
using namespace std;

template <typename T>
constexpr T pi = T(3.1415926535897932385);

auto circle_area(double radius) {
    return pi<double> * radius * radius;
}

int main(int argc, char const *argv[])
{
    cout << "area of circle: " << circle_area(5.0) << endl; 
    return 0;
}
```
프로그램 수행 결과는 다음과 같다. 
```bash
area of circle: 78.5398
```

## decltype(auto)
``dcdltype(auto)`` 자료형 지정자는 ``auto``와 같이 자료형을 추론한다. ``auto``와 달리 reference와 cv-qualifiers를 유지하면서 자료형을 추론한다. ``auto``와 ``decltype(auto)``는 모두 변수의 자료형을 자동으로 추론하며 변수의 선언문에 사용할 수 있으며 변수의 자료형을 명시적으로 지정하지 않아도 된다는 공통점을 가지며 ``auto``는 변수의 값을 기반으로 자로형을 추론하는 반면 ``decltype(auto)``는 변수의 표현식을 기반으로 자료형을 추론한다. 
다음 두개의 프로그램은 ``auto`` 자료형 지정자와 ``decltype(auto)`` 자료형 지정자의 차이점을 보인다. 

(1)
```c++
#include <iostream>
using namespace std;

int main(int argc, char const *argv[])
{
    const int x = 0;
    auto x1 = x; // x1의 자료형은 int
    auto x2 = x; // x2의 자료형은 int 
    x1 = 20;
    x2 = 30;
    cout << "x: " << x << endl;
    cout << "x1: " << x1 << endl;
    cout << "x2: " << x2 << endl;
}
```

(2)
```c++
#include <iostream>
using namespace std;

int main(int argc, char const *argv[])
{
    const int x = 0;
    auto x1 = x; // x1의 자료형은 int
    decltype(auto) x2 = x; // x2의 자료형은 const int 
    x1 = 20;
    x2 = 30;
    cout << "x: " << x << endl;
    cout << "x1: " << x1 << endl;
    cout << "x2: " << x2 << endl;
}
```

(1)의 코드에서 변수 x2는 변수 x에 저장된 값에 의해 자료형이 결정되어 int 형이 된다. 그러므로 ``x2 = 30;`` 의 코드가 실행되어 x2의 값을 출력하면 30이 화면이 출력된다. 
(2)의 코드에서는 변수 x2는 변수 x에 저장된 값 뿐만 아니라 const int 자료형 지정자가 모두 반영되어 ``x2 = 30;`` 의 코드에서 컴파일 에러가 발생한다. ``x2 = 30;``를 주석 처라하고 컴파일하고 실행하면 
화면에 변수 x2의 값으로 0이 출력된다.

다음의 코드의 변수 y2와 변수 y3의 차이점은 결과로 부터 변수 y3이 일반 반수가 아니라 참조변수임을 확인할 수 있다. 

```c++
#include <iostream>
using namespace std;

int main(int argc, char const *argv[])
{
    int y = 0;
    int& y1 = y;  
    auto y2 = y1;  // y2의 자료형은 int
    decltype(auto) y3 = y1;  // y2의 자료형은 int& 

    y1 = 20;
    y2 = 30;
    y3 = 40;
    cout << "y: " << y << endl;    // 40
    cout << "y1: " << y1 << endl;  // 40
    cout << "y2: " << y2 << endl;  // 30
    cout << "y3: " << y3 << endl;  // 40
    return 0;
}
```

## Binary Literals과 Digit Separators
이진 리터널(Binary Literals): 이진수를 이진 리터럴을 사용하여 표현할 수 있으며 십진수의 가독성을 높이기 위해 숫자 사이에 작은 따옴표를 사용하여 표현할 수 있다.
다음 코드는 Binary Literals와 Digit Seperators의 에아다.

```c++
#include <iostream>
using namespace std;

int main(int argc, char const *argv[])
{
    int binaryNumber1 = 0b1010; // == 10 (십진수)
    int binaryNumber2 = 0b0111'1111; // 127 (십진수)
    int billion = 1'000'000'000;

    cout << "binaryNumber1: " << binaryNumber1 << endl;
    cout << "binaryNumber2: " << binaryNumber2 << endl;
    cout << "Digit 분리 표현: " << billion << endl;

    return 0;
}
```
프로그램 수행 결과는 다음과 같다.
```bash
binaryNumber1: 10
binaryNumber2: 127
Digit 분리 표현: 1000000000
```

## User-Defined Literals for Standard Library Types
사용자 정의 리터럴을 사용하여 표준 라이브러리 자료형에 대한 사용자 정의 리터럴을 정의할 수 있다. 이를 통해 개발자는 표준 라이브러리 자료형을 보다 쉽게 사용할 수 있는 방법을 제공할 수 있다.

## 



