# 변수와 상수의 사용 

## 변수

컴퓨터 프로그램에서 변수는 컴퓨터 프로그램에서 처리하는 데이터와 관련이 있는 것으로 데이터를 저장할 수 있는 저장 공간(메모리의 저장공간)을 뜻한다. 
프로그램이 실행 중에 변수의 저장공간에 저장된 값은 변경이 가능하다. 일반 변수의 경우는 변수 이름으로 저장공간에 저장된 데이터 값을 참조할 수 있다. 
일반적으로 컴퓨터 프로그램에서는 프로그램에서 처리하는 데이터의 개수만큼 저장공간이 필요한 경우 그 수 만큼 변수가 필요하다. 또한 처리하는 데이터 형태에 따라 
적합한 변수가 요구된다. 프로그램 실행 중에 데이터를 저장할 저장공간을 할당은 다음에 논의할 **변수 선언**을 통해서 행한다. 

### 변수 이름 만들기

모든 변수들은 이름을 가진다. 변수의 이름은 프로그래머가 만들어야 하기 때문에 변수를 만드는 규칙을 이해하는 것이 필요하다. 또한 다른 저장공간을 할당하는 변수의
이름은 서로 달라야 한다. 하나의 프로그램에서 동일한 이름을 가진 변수가 여러 개 존재할 수 없다. 변수 이름은 필요에 따라 결정하는데 변수 이름을 통해 어떠한 데이터가
저장되는지를 알 수 있도록 만드는 것이 좋다. 이름을 저장하는 변수 이름을 결정하려고 하는데 ```num```이라는 변수 이름을 사용하는 것은 본인 뿐만 아니라 
공동 개발자들에게 혼돈을 줄 수 있으므로 하지 않는 것이 좋다. 즉, 변수의 이름은 변수의 이름으로 저장공간에 저장된 데이터의 의미를 추론할 수 있도록 만드는 것이 좋다.

변수 이름은 식별자(identifier)라고 하며 식별자가 되기 위해서는 다음과 같은 규칙을 따라야 한다. 

* 숫자로 시작하는 변수 이름은 사용할 수 없다. 
* 알파벳 대문자와 소문자는 다른 문자를 구분한다. (그러나 혼돈을 피하기 위해 동일한 이름을 대소문자로 구별하지 않도록 한다.)
* 변수 이름의 길이는 제한이 없다. (개발 환경에 따라 식별자의 길이가 31자로 제한되는 경우도 있다.)
* C++가 예약한 키워드(keyword)는 사용할 수 없다. (키워드의 예: main, class, struct, return)
* 언더바(_)를 제외한 특수문자는 사용이 불가능하다. 
* 영문자, 숫자, 그리고 한글도 가능하고 사용이 가능하다.

### 변수 명명법

최근 소프트웨어 개발 시 여러 개발자가 협업을 하여야 하는 경우가 많다. 하나의 프로젝트에서 모두 동알한 규약으로 변수 이름을 만들도록 하여 코드의 가독성을 
높일 수 있도록 한다. 대표적인 변수 이름 규약은 다음과 같다.

* Camel Casing (카멜표기법)
  + 각 단어의 첫문자를 대문자로 표기하고 붙여쓰는 표기법으로 맨 처음 문자는 소문자로 표기
    - 예) utilityBox, mainFrame, personState
* Pascal Casing (파스칼표기법)
  + 변수 이름의 시작을 대문자로 표기하고 복합어인 경우 중간에 시작하는 새로운 단어의 첫 단어도 대문자로 표기 
  + 카멜표기법과 유사
    - 예) UtilityBox, MainFraome, PersonState
* Hungarian notiation (헝가리안 표기법)
  + 마이크로소프트 개발장 중 헝기리 프로그래머인 찰스 시모니(Charles Simonyi)가 쓰던 변수 이름 규정으로 마이크로소프트 내부에서 사용되던 표기법
  + 최근들어 IDE의 발달로 변수에 커서만 가져가면 해당 변수의 각종 정보를 보여주는 기능을 지원하여 지금은 마이크로소프트도 공식 가이드라인에서 사용하지 말 것을 권고
    - 예) int자료형 + apple -> intApple 
* GNU 이름 규칙
  + 모두 소문자를 사용하고 복합어 사이를 ``'_'``를 사용하여 연결한다.
    - 예) gtk_widget_activate

## 변수 선언 

프로그램에서 데이터를 처리하기 위해서 데이터를 저장할 저장공간이 요구된다. 즉 변수를 사용하기 위해서는 
저장공간이 할당(변수 선언)이 필요하다. 저장공간을 할당하는 과정은 다음 형식을 따른다.

```<자료형> <변수이름1>, <변수이름2>, <변수이름3>;```

예로 전구의 밝기를 제어하는 프로그램을 작성하고자 한다. 전구의 밝기가 0 ~ 255 까지 정수 값으로 제어하는 프로그램에서 
밝기를 저장하는 변수 ```bulbBrightness``` 를 선언하고자 한다. 최소의 저장공간을 할당하는 자료형으로 선언하는 것은 다음과 같다.

```C++
unsigned char bulbBrightness;        // 변수 bulbBrightness 선언
```

앞과 같이 ```bulbBrightness``` 변수를 선언하면 1바이트의 저장공간이 할당된다. 할당된 저장공간에는 임의의(random) 값이 저장된다. 
변수의 선언은 저장공간을 활용하기 전 (변수에 데이터 값의 저장, 데이터 값의 변경 등 데이터를 처리하기 전)에 이루어지기만 하면된다.

변수 선언문에 같은 자료형의 저장공간 여러 개를 동시에 선언할 수 있다.

```C++
unsigned char bulbBrightness, doorBulbBrightness; 
```

### 변수 초기화

변수 선언과 함께 변수(저장공간)에 원하는 값을 저장할 수 있다. 이를 **변수 초기화** 라고 한다. 
C++에서는 세 가지 방법이 사용된다. 

첫번쨰는 **대입연산자 (=)** 를 이용하는 것으로 **복사 초기화**이다.  
대입연산자의 의미는 오른쪽의 값을 왼쪽의 변수에 저장하라는 뜻이다.
대입연산자를 적용할 때 기본적으로 왼쪽 데이터의 형태와 오론쪽 데이터 형태가 같아야 한다. 

변수에 데이터를 저장하기 위해서  
앞의 변수 ```bulbBrightness```를 선언할 때 대입연산자를 사용하여 저장공간에 100을 저장하는(초기화) 코드는 다음과 같다.

```C++
unsigned char bulbBrightness = 100; // 변수 bulbBrightness 선언과 동시에 저장 값 초기화 
```

두번쨰는 소괄호 ()를 사용하여 직접 초기화하는 방법이다. **직접 초기화**는 일부 데이터 형태에서 복사 초기화 보다 성능이 더 뛰어날 수 있다.
대입연산자를 이용한 초기화를 직접 초기화를 통한 초기화 코드는 다음과 같다.

```unsigned char bulbBrightness(100);```

앞의 복사 초기화와 직접 초기화는 일부 데이터 자료형의 변수에 대해서만 동작한다. 모든 데이터 자료형에서 동작하는 일관된 초기화 메커니즘을 제공하기 위해
C++ 11에서 **유니폼 초기화(uniform initializaion)** 라는 새로운 초기화 메커니즘을 추가했다. 
유니폼 초기화로 초기화하는 코드는 다음과 같다. 

```C++
unsigned char bulbBrightness {100}
```
## 변수에 데이터 저장하기 

변수에 값을 저장하는 연산자는 **대임연산자(assignment operator)** 이다. 앞에서 변수 초기화에서 보았듯이 대입연산자는 등호(=)이다. 
대입연산자의 의미는 오른쪽의 값을 왼쪽의 변수에 저장하라는 뜻이다. 대입연산자를 적용할 때 기본적으로 왼쪽 데이터의 형태와 오론쪽 데이터 형태가 같아야 한다. 

다음 코드 ```variable = data;```는 왼쪽의 variable은 이미 선언한 변수에 해당되고 오른쪽의 data로는 실제 대이터 값 (리터럴 데이터: literal data), 변수, 수식이 될 수 있다.

* 변수에 리터럴 데이터를 대입하는 예는 다음과 같다.  
```C++
programScore = 'A';   // 문자 자장 
myHeight = 175.3;     // 실수 저장 
carQuantity = 4;      // 정수 저장
velocity = 2.99792E+8;    // 실수 저장
```

* 다음은 변수에 리터럴 데이터의 연산 결과, 저장된 값의 대입, 변수와 리터럴 데이터와의 연산 결과를 대입하는 예는 다음과 같다.

```C++
finalScore = programScore;  
circleArea = 3.14 * circleRadius * cricleRadius;
rectArea = rectHeight * rectWidth;
salePrice = 10 * 0.6; 
```

## 상수 선언 

상수는 앞에서 설명하였듯이 메모리의 저장공간에 저장된 값을 변경하지 못하는 저장공간을 뜻한다. C++에서 두 가지 의미의 불변성(immutability)을 제공한다.

### const

그중 하나가 ```const``` 키워드이다. ```const```는 **"이 값을 변경하지 않는다는 약속"** 의 의미로 함수에 데이터를 포인터나 레퍼런스 형태로 전달할 때 데이터 
값을 변경하지 않는다는 것을 인터페이스에 명시하길 원할 때 사용한다. 컴파일러는 ```const``` 로 명시된 약속을 지키도록 강제하지만 ```const``` 값은 **실행 시
계산될 수도 있다.** 
변수를 상수로 설졍하는 것은 변수의 자료형 앞이나 다음에 ```const``` 키워드를 사용하면 된다.  변수를 상수로 설정하는 경우 선언할 때 초기화하여야 하며 선언 후 변수처럼 대입연산자로 값을 변경할 수 없다. 

```C++
const double gravity {9.8};   // const 키워드를 자료형 앞에 두는 것이 관행
int const sidesInSqure {4};
```
### constexpr

다른 하나는 ```constexpr```로 상수 표현식을 뜻하나 const와 같이 변수에 대해서도 적용 가능하다. 이는 객체나 함수를 ```const```로 만들어 주는 역할을 한다. **"이 값은 컴파일 시간에 평가한다"** 는 의미로 주로 컴파일 시 미리 연산 결과를 구하여 상수로 지정하여 텍스트 영역이라 블리는 읽기 전용 메모리(read-only memory)에 저장한다. ```constexpr```은 반드시 컴파일 시간에 계산된다. 

```constexpr```의 장점은 다믕과 같다.

* 컴파일 시에 미리 예측이 가능한 값으로 이루어진 연산이나 함수의 결과를 계산하고 저장해 두기 떄문에 실행 시 값을 읽어오기만 하면 되므로 성능을 향상 시킬 수 있는 장점이 있다.
* 배열 선언 시 요소의 개수와 같이 상수 값 만을 사용하여야 하는 경우 과거에는 ```const``` 나 ```enum```을 사용하여야 하지만 이제는 함수도 사용이 가능하다.
(이 경우에도 함수의 인자들은 모두 컴파일 시 알 수 있어야 한다.)

#### ```constextpr``` 객체

```constexpr``` 객체는 반드시 컴파일 시 계산되어야 한다. 반면 C++98 부터 적용했던 ```const``` 는 앞에서도 언급했듯이 컴파일 시 정해져야 한다는 규칙은 없다. 
그러므로 모든 ```constexpr``` 객체는 ```const``` 이지만 모든 ```const```  객체는 ```constexpr```이 아니다. 
컴파일러에 의해 평가되는 표현식에 함수를 사용하며 그 함수도 ```constexpr```로 정의해야 한다.

```C++
double sum(const vector<double>&);
vector<double> v {1.0, 2.0, 3.0, 4.0};
const double s1 = sum(v);
constexpr double s2 = sum(v);
```
앞의 경우 ```const```로 정의된 변수 s1의 표현식에 사용한 함수 sum(v)가 실행 시점에 계산이 되어도 되기 때문에 컴파일 시 에러가 발생하지 않으나 ```constexpt```로 정의된 s2의 경우 표현식에 사용된 sum(v)가 컴파일 시 계산되지 않기 때문에 에러가 발생한다. 

#### ```constextr``` 함수

```constexpr``` 함수는 전달되는 인자(argument)가 모두 constexpr 인 경우 컴파일 시 미리 계산된다. 인자 중 하나라도 컴파일 시 알 수 없는 값일 경우는 
실행 시 실행되는 일반 함수랑 같이 동작한다. 이 경우 컴파일 오류가 발생하지 않는다. 그러나 함수 결과 값을 ```constexpr```로 선언된 상수에 대입하는 경우에는
오류가 발생한다. 즉, 같은 동작으로 하는 함수를 ```constexpr```의 상수 버전과 실행 시 실행되는 일반 함수 버전으로 두번 정의하지 않아도 된다. constexpr 함수 
하나만 정의되면 두 경우에 모두 사용할 수 있다. 

```C++
constexpr double square(double x) {return x*x;}

constexpr double max1 = 1.4 * square(4);     // (1)
constexpr double max2 = 1.4 * square(var);   // (2)
onst double max3 = 1.4 * square(var);        // (3)
```

앞의 코드에서 (1)의 오른쪽 표현식은 컴파일 시 값을 구할 수 있기 때문에 오류가 발생하지 않는다. (3)의 경우는 변수 max3 가 ```const``` 로 정의되어 있기 때문에 오른쪽의 표현식이 실행 시점에 계산이 되어도 되기 때문에 에러가 발생하지 않는다. 그러나 (2)의 경우는 square() 함수의 인자로 변수 var가 사용되고 있는데 이 인자가 컴파일 시 결정할 수 없는 경우에는 에러가 발생하게 된다. 

함수를 ```constexpr```로 정의하려면 함수의 내용이 간단하고 부수 효과가 없어야 하고 파러미터로 전단될 정보만 사용해야 한다. 지역 변수가 아닌 변수는 변경할 수 없다. 

* ```constexpr``` 객체는 컴파일 시 대입된 값으로 초기화된 ```const```이다. 
* ```constexpr``` 함수는 컴피일 시 정해진 값으로 인자가 결정된 경우 그 결과는 컴파일 시 결과 값이 만들어지는 함수이다. 
* ```constexpr``` 객체, 함수는 일반 객체, 함수에도 적용이 가능하다. 




