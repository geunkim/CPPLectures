# 프로그램 기본 요소

## 변수와 상수

컴퓨터 프로그램은 실생활의 다양한 데이터를 처리하는 것이다. 
컴퓨터 메모리에 저장된 데이터의 값을 변경할 수 있는지 없는지에 따라 변수(variable)와 상수(constant)로 구분된다. 
변수는 수학에서 미지수와 같이 대입한 값을 변경할 수 있는 것과 같이 프로그램 수행 중에 메모리에 저장된 값을 변경할 수 있는 것이고 
상수는 전공에서의 빛의 속도, 원주율, 중력 가속도 등과 같이 값이 결정되어 있어 변경할 수 없는 것으로 
프로그램 수행 중에 메모리에 저장된 값을 변경할 수 없는 것이다.

- 프로그램에서 변수: 저장된 내용이 변경이 가능한 메모리의 저장공간
- 프로그램에서 상수: 메모리의 저장공간에 한 번 저장할 수 있으며 저장 후 변경이 불가능한 저장공간 

## 컴퓨터의 데이터 표현

우리가 일상생활에서 널리 사용되는 10진수 체계는 차지하는 자리 공간(위치)에 따라 10의 지수 형태 (10^n: n = 0..)를 가진다 (^는 거듭제곱 연산을 나타냄). 즉 수의 오른쪽 끝부터 1, 10, 100, 1,000, 10,000 등의 자릿 값을 가진다. 다음의 10진수 345가 있다고 하자. 345는 세 개의 자리 공간을 차지하며 5가 있는 자리는 10^0, 4의 자리는 10^1, 3의 자리는 10^2의 값을 가진다. 그러므로 
```
345 = 3 * 100 + 4 * 10 + 4 * 1
``` 
라는 의미이다. 

컴퓨터에 저장되는 모든 데이터는 2진수로 표현된다. 2진수는 10진수와 같이 여러 자리 공간을 차지하는데 각 자리 공간마다 0과 1의 값을 가지며 수의 오른쪽 끝부터 
0(2^0), 2(2^1), 4(2^2), 8(2^3),... 의 자리 값(이때의 자릿값은 10진수의 값)을 가진다. 2진수로 표현할 때 자리 공간 하나를 비트(bit)라고 한다. 

예로 2진수 1101을 10진수로 표현하면 1 * 8 + 1 * 4 + 0 * 2 + 1 * 1 의 의미이다. 즉, 2진수 1010은 10진수로 13을 의미한다. 이 관계로부터 10진수 값은 2진수로 표현이 가능함으로 추론할 수 있다.

### 2진수를 사용한 10진수 정수 표현

앞에서 2진수로 10진수를 표현할 수 있다는 것을 간단하게 살펴보았다. 이제 10진수 정수를 2진수로 표현하는 방법에 대해서 상세하게 살펴보았다. 
10진수 정수는 양수, 0, 음수로 구분된다. 그러므로 2진수의 컴퓨터에 10진수 정수를 저장하기 위해서는 양수와 음수를 구분하는 부호 비트가 필요하다. 
2진수로 10진수 정수를 표현하기 위한 가장 기본적인 방법은 아래와 같은 부호와 값의 영역으로 나누어 표현하는 방법이 있다.

#### 부호-크기 표현 

부호-크기 표현방법은 MSB(Most Significant Bit)의 부호 비트를 제외한 나머지 부분은 값을 표현하는 데 사용한다.
MSB가 0이면 양수, 1이면 음수를 뜻한다. 
8bit를 활용하여 정수를 표현하는 경우를 고려하자. 
```
+19 : 00010011
-19 : 10010011
```
8bit의 저장공간으로 정수를 표현할 경우 -127 ~ +127까지의 값을 표현한다. 이 경우 +0, -0 이 존재하기 때문에 대부분의
컴퓨터는 이 방식을 사용하지 않는다. 그리고 덧셈과 뺄셈 연산 과정이 복잡해진다. 이러한 문제를 해결하기 위해 보수 개념이 
활용된다. 


#### 보수 표현
보수 개념은 파스칼이 10진수 연산을 위해 제안된 것이다. 
10진수에서 보수는 10의 보수와 9의 보수가 존재하고 2진수에서 보수는 2의 보수와 1의 보수가 존재한다. 

10진수 11의 보수로 9의 보수와 10의 보수가 있다. 10의 9의 보수는 99-11 = 88 이고 10의 보수는 89이다.
다음의 뺄셈을 고려해 보자.  
  * 20 - 11
  * 20 - 30
  * 20 - 20
  
```20 - 11``` 연산을 10의 보수를 이용한 덧셈으로 변경하면 (20 + 89) = 109 가 얻어진다.
여기서 두 자리 범위를 넘어간(오버플로우) 1가 발생하면 나머지 두 자리의 값(09)으로부터 ```9```의 값을 얻게 되고 이것이 
```20 - 11```의 결과이다. 

```20 - 30``` 연산을 10의 보수를 이용한 덧셈으로 변경하면 (20 + 70) = 90 가 얻어진다. 
여기서 두 자리 범위를 넘어간 수(오버플로우)가 0이므로 나머지 두 자리의 값인 90은 음수이다. 90의 10의 보수가 10이므로 
결과값은 ```-10``` 이라는 결과를 얻을 수 있다. 

```20 - 20``` 연산을 10의 보수를 이용한 덧셈으로 변경하면 (20 + 80) = 100 가 얻어진다. 결과 값은 ```0```이 된다. 
이를 9의 보수를 이용한 덧셈으로 변경하면 (20 + 79) = 99 가 얻어진다. 오버플로우가 발생하지 않으므로 9의 보수 "99" 도 0의 값을 가진다.

2진수 00110110 은 10진수로 54 이고 1의 보수는 11001001이고 2의 보수는 11001001 + 1 = 11001010 이다.
일반적으로 __2의 보수 = 1의 보수 + 1__ 이다. 

앞에서 논의했던 두 식을 2진수로 연산하는 것을 살펴보자. 앞의 10진수 11, 20, 30을 부호 비트가 있는 1바이트(8비트)의
저장공간을 사용하여 표현하면 00001011, 00010100, 00011110 이다.

```20 - 11 ```을 2의 보수를 활용하여 연산하면 ```00010100 + 11110101```로 표현되고 결과는 **1**00001001 로 오버플로우가 발생하여 최종 결과는  ```00001001```로 10진수 9이다. 

```20 - 30```을 2의 보수를 활용하여 연산하면 ```00010100 + 11100010``` 로 표현되고 결과는 11110110 로 오버플로우는 발생하지 않고 MSB가 ```1```로 음수이다. ```11110110```의 2의 보수가 00001010으로 10진수로 -10이다. 

 ```20 - 20```을 1의 보수를 활용하여 연산하면 ```00010100 + 11101011```로 표현되고 결과는 11111111 로 1의 보수의 경우 0의 의미를 가진다.
 이를 2의 보수를 활용하여 연산을 하면 ```00010100 + 11101100``` 로 표현되고 결과는 **1**00000000 로 0의 결과를 갖는다. 
 2의 보수의 경우 0이 하나지만 1의 보수는 0이 **00000000**과 **11111111** 두 개가 있다. 
 그러므로 음수를 표현할 경우 2의 보수를 사용한다. 


#### 저장 공간의 크기와 표현이 가능한 정수 값 

8bit로 표현하면 1bit가 부호 비트로 사용된다. **0**0000000 은 0, 양수는 2진수로 **0**0000001 ~ **0**1111111 범위를 가지며 이는 10진수로 +1 ~ +127 의 수를 표현한다. 

10진수 -1은 1의 보수로 **1**1111110 이다. 
1 + (-1)을 하면 00000001 + 11111110 = 11111111 이 되며 ```11111111```도 -0이 되어야 한다.
1의 보수로 음수를 표현하면 **1**0000000 ~ **1**1111110 범위를 가지며 이는 10진수로 -127 ~ -1의 수를 표현한다.
그리고 0의 값이 +0, -0의 값으로 **0**0000000, **1**1111111 두 개를 가진다. 
그러므로 1의 보수로 표현할 경우 -127 ~ +127 의 수를 표현하고 0을 표현하는 것이 2 개가 된다. 

10진수 -1은 2의 보수로 **1**1111111 이다. 
1 + (-1)을 하면 00000001 + 11111111 = 00000000 으로 0이 된다.
-127은 2의 보수로 **1**0000001 이다. **1**0000000은 10진수로 -128이 된다. 
그러므로 2의 보수로 표현한 경우 -128 ~ +127 의 수를 표현할 수 있다. 

정수를 저장하는 공간을 1bit를 부호 비트를 사용하는 16bit로 표현한다고 하면 -32,768 ~ +32767 의 범위의 수를 표현한다.

정수를 저장하는 공간으로 N bit(부호 비트: 1bit) 사용한다면 ```-(2^N) ~ +(2^N - 1)``` 의 범위의 10진수를 표현한다.

### 2진수를 사용한 10진수 실수 표현 

컴퓨터에서 10진수 실수를 2진수로 표현하는 방법은 10진수 정수를 2진수로 표현하는 방식보다 복잡하다. 
10진수 실수 값은 소수점을 기준으로 정수 부분과 소수 부분으로 구분된다. 
정수 부분은 10진수 정수를 표현하는 방법과 같으며 소수 부분의 표현은 2의 음수 지수의 형태로 표현된다. 
소수 부분의 자리 공간에 따른 값은 다음 그림과 같다. 소수점을 기준으로 바로 오른쪽 공간의 값은 아래의 표와 같다. 

![screensh](./images/binary_num.png)

예로 10진수 0.625를 2진수로 표현하면 0.101이다. 0.101 = 1 * 0.5 + 0 * 0.25 + 1 * 0.125 로 10진수 0.625는 2진수 0.101 이 된다. 
10진수 0.725를 2진수로 표현하면 0.11이다. 아래의 표를 살펴보면 소수 부분은 (1/2)의 거듭제곱의 합으로 표현되고 있다.

![screensh](./images/bin_dec_map.png)
	
만약 10진수 0.4를 2진수로 표현하면 0.00110011.... 의 형태로 (0011)이 무한 반복된다. 즉 표에서 알 수 있듯이 비트의 수가 유한한 2진수로  
표현하지 못하는 소수가 존재하기 때문에 컴퓨터에는 표현할 수 있는 가장 근사치 갑이 저장된다. 
이러한 근사 값을 저장하는 방법에는 __고정소수점__ 과 __부동소수점__ 의 두 가지 형태가 있다. 

#### 고정소수점 표현방식

고정소수점 표현방식은 정수 부분을 표현하는 비트 수와 소수를 표현하는 비트 수를 사전에 정한 후 해당 비트 수만을 사용하여 수를 표현하는 방식이다.
만약 정수를 표현하는 비트를 증가시키면 큰 수를 표현할 수 있으나 정밀한 수를 표현하는 것이 어렵지만,
소수를 표현하는 비트 수를 늘리면 정밀한 수를 표현할 수 있으나 큰 수를 표현할 수 없다. 
이 문제를 해결하기 위해서 소수점의 위치를 고정하지 않고 소수점의 위치를 움직일 수 있도록 하는 부동소수점 표현방식이 있다. 

예로 432.4를 4 bytes(32bits)의 저장 공간을 활용하여 정수 표현에 16bits, 소수 표현에 15bits를 부호에 1bit를 사용한다면 다음과 같다.

```(0)000000110110000.001100110011001```

#### 부동소수점 표현방식

부동소수점을 표현하는 방식도 양식에 따라 다를 수 있으나 일반적으로 사용하는 방식은 IEEE에서 표준으로 제안한 방식 (IEEE 754 표준) 이다.
부동소수점 표현방식은 가수부와 지수부로 표현하는 방식으로 다음과 같은 수식을 이용하여 큰 실수까지도 표현이 가능하다. 

```
+/-(1.가수부)x2^(지수부-127)
```
아래는 32 비트로 사용하여 실수를 표현할 때 지수부와 가수부의 할당을 IEEE 부동소수점 표준에 따라 나타낸 것이다.

![screensh](./images/float_real.png)

다음은 64 비트를 사용하여 실수를 표현할 때 지수부와 가수부의 할당을 IEEE 부동소수점 표준에 따라 나타낸 것이다. 

![screensh](./images/double_real.png)

#### 부동소수점 표현방식의 오차

부동소수점 표현방식을 활용해서 실수를 표현할 경우 실수를 정확하게 표현하지 못하고 근사치로 표현되는 경우가 있다.
부동소수점 표현방식으로 실수를 표현할 떄 오차를 보여주는 예제로 0.2를 1000번 더하면 예상되는 결과는 200 이 되어야 하는데
프로그램 실행 결과는 199.998 로 계산된다. 

```C++
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
	float sum = 0.0;

	for(int a = 0; a < 1000; a++)
		sum += 0.2; 

	cout << sum << endl;

	return 0;
}
```
다음과 같은 결과를 얻었다. 
```
199.998
[Finished in 5.4s]
``` 
### 2진수를 사용한 문자 표현

일상생활의 문자도 컴퓨터에 저장되는 경우 2진수를 사용하여야 한다. 또한 문자는 영문 알파벳뿐만 아니라 한글 등의 각국의 문자가 저장되어야 하므로 각 문자를 구분하기 위한 방법을 고려하여야 한다. 다양한 문자를 표현하기 위해서 각 문자별로 2진수의 코드 값을 부여한 코드체계를 이용하는 것이다.
이들 코드체계로는 아스키코드(ASCII: American Standard Code for Information Interchange  Code)와 유니코드(Unicode) 등이 있다.
아스키 코드는 미국국가표준협회(ANSI: American National Standard Institute)에서 영문 알파벳으로 이루어진 문서를 저장하고 컴퓨터간 문서 데이터를 교환하기 위해 문자를 인코딩하기 위해 아스키코드가 사용되었다. 

#### 아스키코드 (ASCII Code)
아스키코드는 7bit(3개의 zone bit, 4개의 digit bit)로 구성되어 33개의 출력 불가능한 제어 문자와 공백을 비롯한 95개의 출력 가능한 문자 128개의 문자를 표현하기 위해 개발되었다. 3개의 zone bit는 영문자, 숫자, 특수문자를 구분하는 데 사용된다.
제어 문자들은 이제 대부분 사용되지 않고 있으며 출력 가능한 문자는 52개의 대소문자 알파벳과 10개의 숫자, 1개의 공백문자, 32개의 특수문자로 구성된다. 아스키코드는 ISO/IEC 646 표준이 되었고 아스키코드 앞에 0을 넣어 8bit 코드를 만든 IBM 코드 페이지와 ISO 8859 가 있다.

![screensh](./images/ASCII_CODE.png)

아스키 코드에 의하면 대문자 'A'는 10진수로 65이고 소문자 'a'는 10진수로 97이다. 이는 문자 'A'를 아스키 코드로 저장하면 저장공간에는 2진수로 01000001 가 저장되고 문자 'a'를 저장하면 저장공간에는 2진수로 0110001가 저장된다. 

#### ANSI 코드

ASCII 코드를 확장하여 각 나라의 문자를 표현하기 위한 방법으로 표준화된 것으로 각 나라의 확장된 부분의 이름을 따서 EUC-KR, EUC-JP 라 부른다. 
문자열 "B가" ANSI 형식으로 저장할 경우 영문 알파벳은 ASCII 코드에서 할당된 한 바이트를 사용하고 '가'와 같은 문자는 확장된 코드표에서 할당된 두 바이트를 사용한다. 
EUC-KR은 한글과 한국에서 통용되는 한자 그리고 영문을 표현할 수 있을 뿐 다른 나라의 문자를 표현할 수 없다. "B가"를 저장하기 위한 저장 공간은 3byte 이다. 

|      B     |     가     |
|------------|------------|
|      41    | B0  A1     |

#### 유니코드 (UniCode)

유니코드는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현할 수 있는 표준 문자 코드표로 컴퓨터 간 문자 데이터 교환을 원활하게 하기 위해 유니코드 협회가 제정하였다. 
유니코드는 문자를 표현하기 위해서 16bit를 할당하여 65,536개의 문자를 표현할 수 있는 문자 집합으로 아스키코드를 포함한다. 아스키코드를 유니코드로 표현할 때는 
**0000 0000**을 붙인다. 아스키코드는 U+0000 ~ U+007F 영역에 매핑된다. 유니코드는 각 문자 집합을 영역 또는 블록이라 하고 각 영역 또는 블록 내의 각 문자는 코드 포인트(Code Point)가 매핑되며 한 코드 영역은 다른 코드 영역과 겹치지 않으며 영역의 크기는 16의 배수이고 각 영역은 16의 배수(U+nnnn)의 코드 포인트로 시작된다.

유니코드는 기본 다국어 평면(BMP, Basic Multilingual Plane)을 포함하여 16개의 평면으로 구성되면 기본 다국어 평면은 65,536개의 코드 포인터를 가지고 있으며 한글도 이 평면에 매핑된다. 한글은 U+AC00 ~ U+D7AF 영역에 매핑된다. 유니코드의 인코딩 방식으로 UTF(Universal Transformation Format)-8, UTF-16 등이 있다. UTF-16 코딩 방식으로 표현하면 문자가 2바이트씩 할당한다. UTF-8 코딩 방식은 ASCII 영역은 1바이트, 유럽 문자는 2바이트, 아시아 문자는 3바이트로 표현하는 코드이다. 

"AB가나" 문자열을 UTF-16으로 표현하면 아래와 같이 저장된다. 

|    A | B   |     가 |  나    |
|-------|-----|------|------|
| 00 41 | 00 42 | AC 00 | B0 98 |

"AB가나" 문자열을 UTF-8으로 표현하면 아래와 같이 저장된다. 

|    A | B   |     가 |  나    |
|-------|-----|------|------|
| 41  | 42  | EA Bo 80|  EB 82 98 |  




