# C++ Design Pattern (디자인 패턴)

Don't reinvent the wheel. 

디자인 패턴은 소프트웨어 설계 시 특정 상황(context)에서 자주 발생하는 문제를 해결할 때 재사용할 수 있는 해볍이다.
이미 잘 만들어져서 잘 동작하는 것을 처음부터 다시 만들 필요가 없기 때문에 디자인 패턴은 프로그래머로서 필히 알아야 할 지식이다. 

## Pattern
다양한 응용 소프트웨어 시스템은 공통되는 설계 문제를 가지고 있으며 이를 처리하는 해결책에는 공통점 있다. 이러한 공통점을 패턴이라 한다.
패턴은 동일한 언어로 만들어 지며 팀원 사이의 의사 소통을 원활하게 해주는 아주 중요한 역할을 한다.

## 디자인 패턴을 공부 또는 적용할 때 고려할 내용

특정한 문제에 대한 일반적이고 포괄적인 방법을 적용하는 경우 오버 엔지니어링(Overengineering)[^1] 이 되기 쉽다. 
패턴 자체에 집착하면 실제 필요한 것보다 훨씬 더 복잡한 구조를 만들기 쉬우지 유의하여야 한다. 

## CRTP (Curiously Recurring Template Pattern)

클래스 X가 X 자신을 템플릿 인자로 사용하여 클래스 템플릿 인스턴스화로 부터 파생되게 하는 C++ idiom(관용어) 이다. 이 idiom의
이름은 1995년 Jim Coplien가 처음 언급했다. 파새

```C++
template<class T>
class Base
{
  // methods within Base can use template to access members of Derived
};
class Derived : public Base<Derived>
{
  //...
}
```

CRTP 패턴의 사용 사례로 정적 다형성 (Static Polymorphism)과 Modern C++ Design 에서 기술된 메타프로그래밍 기술이 있다.

### 정적 다형성 

동적 다형성[^2]은 상속에 의한 하위 클래스가 제공하는 인터페이스는 상위 클래스에 미리 설계된 인터페이스로 한정(bounded)되어 미리 결정되며 인터페이스와의 바인딩은 실행 중에 이루어지는 것을 말한다. 반면, 정적 다형성은 인터페이스와의 연결을 컴파일 때 결정되는 것을 의미하는 것으로 template을 사용하여 구현한다. 정적 다형성은 동적 다형성에 비해 생성된 코드의 인터페이스 연결이 컴피일 때 결정되나 다형성 동작에 참여하는 인터페이스가 한정되지 않는다. 

정적 다형성은 일반적인 인스턴스 공통성을 공통 기반 클래스를 통해 표현될 필요가 없어 내장 데이터 형의 모둠이 쉽게 구현된다. 포인터를 통한 간접 지시가 필요한 동적 다형성에 비해 생성된 코드는 잠재적으로 더 빠르며 애플리케이션에서 일부만이 사용될 경우 부분 인터페이스만을 저공하는 실제 객체도 사용될 수 있다는 장점을 가진다. 

정적 다형성은 모든 바인딩을 컴파일 시 검사하여 템플릿으로 인스턴스환된 컨테이너에 잘못된 데이터형의 객체가 삽입될 위험이 적기 떄문에 동적 다형성보다 데이터의 안정성이 높다고 인식된다. 그러나 템플릿 언스턴스도 인스턴스 내부의 여러 구문 때믄에 어려움을 걲을 수 있다. 특정 연산자(예: +)를 가지는 템플릿이 해당 연산자를 가지지 않는 데이터형으로 인스턴스화될 때 문제가 발생할 수 있다.



## 참고자료

Book: 모던 C++ 디자인 패턴 - 드미트리 네스터룩 (원서: Design Patterns in Modern C++' by Dmitri Nesteruk).
C++11 표준 이후의 C++를 모던 C++라고 한다. 

이 책의 예제 소스는 [길벗 깃허브 저장소]와 [원서 소스 코드 저장소]를 참조 하면 된다. 


[걸벗 깃허브 저장소]: https://github.com/gilbutITbook/007028
[원서 소스 코드 저장소]: https://github.com/Apress/design-patterns-in-modern-cpp
[^1] 오버 엔지니어링: 요구한 것 보다 과도한 성능 또는 기능을 제공하는 것 
[^2] 상속에 의해 구현되는 다형성은 동적 다형성이라고 하고 템플릿에 의해 구현된 다형성을 정적 다형성이라 한다.
